<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>HkeyPerformanceDataUtil.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">oshi-core-shaded</a> &gt; <a href="../index.html" class="el_bundle">oshi-core</a> &gt; <a href="index.source.html" class="el_package">oshi.driver.windows.registry</a> &gt; <span class="el_source">HkeyPerformanceDataUtil.java</span></div><h1>HkeyPerformanceDataUtil.java</h1><pre class="source lang-java linenums">/*
 * MIT License
 *
 * Copyright (c) 2020-2021 The OSHI Project Contributors: https://github.com/oshi/oshi/graphs/contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package oshi.driver.windows.registry;

import java.util.ArrayList;
import java.util.Collections;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.sun.jna.Memory; // NOSONAR squid:S1191
import com.sun.jna.platform.win32.Advapi32;
import com.sun.jna.platform.win32.Advapi32Util;
import com.sun.jna.platform.win32.Win32Exception;
import com.sun.jna.platform.win32.WinBase.FILETIME;
import com.sun.jna.platform.win32.WinError;
import com.sun.jna.platform.win32.WinPerf.PERF_COUNTER_BLOCK;
import com.sun.jna.platform.win32.WinPerf.PERF_COUNTER_DEFINITION;
import com.sun.jna.platform.win32.WinPerf.PERF_DATA_BLOCK;
import com.sun.jna.platform.win32.WinPerf.PERF_INSTANCE_DEFINITION;
import com.sun.jna.platform.win32.WinPerf.PERF_OBJECT_TYPE;
import com.sun.jna.platform.win32.WinReg;
import com.sun.jna.ptr.IntByReference;

import oshi.annotation.concurrent.ThreadSafe;
import oshi.util.platform.windows.PerfCounterWildcardQuery.PdhCounterWildcardProperty;
import oshi.util.tuples.Pair;
import oshi.util.tuples.Triplet;

/**
 * Utility to read HKEY_PERFORMANCE_DATA information.
 */
@ThreadSafe
public final class HkeyPerformanceDataUtil {

<span class="nc" id="L61">    private static final Logger LOG = LoggerFactory.getLogger(HkeyPerformanceDataUtil.class);</span>

    /*
     * Do a one-time lookup of the HKEY_PERFORMANCE_TEXT counter indices and store
     * in a map for efficient lookups on-demand.
     */
    private static final String HKEY_PERFORMANCE_TEXT = &quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib\\009&quot;;
    private static final String COUNTER = &quot;Counter&quot;;
<span class="nc" id="L69">    private static final Map&lt;String, Integer&gt; COUNTER_INDEX_MAP = mapCounterIndicesFromRegistry();</span>

    private HkeyPerformanceDataUtil() {
    }

    /**
     * Reads and parses a block of performance data from the registry.
     *
     * @param &lt;T&gt;
     *            PDH Counters use an Enum to identify the fields to query in either
     *            the counter or WMI backup, and use the enum values as keys to
     *            retrieve the results.
     * @param objectName
     *            The counter object for which to fetch data
     * @param counterEnum
     *            Which counters to return data for
     * @return A triplet containing the results. The first element maps the input
     *         enum to the counter values where the first enum will contain the
     *         instance name as a {@link String}, and the remaining values will
     *         either be {@link Long}, {@link Integer}, or {@code null} depending on
     *         whether the specified enum counter was present and the size of the
     *         counter value. The second element is a timestamp in 100nSec
     *         increments (Windows 1601 Epoch) while the third element is a
     *         timestamp in milliseconds since the 1970 Epoch.
     */
    public static &lt;T extends Enum&lt;T&gt; &amp; PdhCounterWildcardProperty&gt; Triplet&lt;List&lt;Map&lt;T, Object&gt;&gt;, Long, Long&gt; readPerfDataFromRegistry(
            String objectName, Class&lt;T&gt; counterEnum) {
        // Load indices
        // e.g., call with &quot;Process&quot; and ProcessPerformanceProperty.class
<span class="nc" id="L98">        Pair&lt;Integer, EnumMap&lt;T, Integer&gt;&gt; indices = getCounterIndices(objectName, counterEnum);</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">        if (indices == null) {</span>
<span class="nc" id="L100">            return null;</span>
        }
        // The above test checks validity of objectName as an index but it could still
        // fail to read
<span class="nc" id="L104">        Memory pPerfData = readPerfDataBuffer(objectName);</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">        if (pPerfData == null) {</span>
<span class="nc" id="L106">            return null;</span>
        }
        // Buffer is now successfully populated.
        // See format at
        // https://msdn.microsoft.com/en-us/library/windows/desktop/aa373105(v=vs.85).aspx

        // Start with a data header (PERF_DATA_BLOCK)
        // Then iterate one or more objects
        // Each object contains
        // [ ] Object Type header (PERF_OBJECT_TYPE)
        // [ ][ ][ ] Multiple counter definitions (PERF_COUNTER_DEFINITION)
        // Then after object(s), multiple:
        // [ ] Instance Definition
        // [ ] Instance name
        // [ ] Counter Block
        // [ ][ ][ ] Counter data for each definition above

        // Store timestamp
<span class="nc" id="L124">        PERF_DATA_BLOCK perfData = new PERF_DATA_BLOCK(pPerfData.share(0));</span>
<span class="nc" id="L125">        long perfTime100nSec = perfData.PerfTime100nSec.getValue(); // 1601</span>
<span class="nc" id="L126">        long now = FILETIME.filetimeToDate((int) (perfTime100nSec &gt;&gt; 32), (int) (perfTime100nSec &amp; 0xffffffffL))</span>
<span class="nc" id="L127">                .getTime(); // 1970</span>

        // Iterate object types.
<span class="nc" id="L130">        long perfObjectOffset = perfData.HeaderLength;</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">        for (int obj = 0; obj &lt; perfData.NumObjectTypes; obj++) {</span>
<span class="nc" id="L132">            PERF_OBJECT_TYPE perfObject = new PERF_OBJECT_TYPE(pPerfData.share(perfObjectOffset));</span>
            // Some counters will require multiple objects so we iterate until we find the
            // right one. e.g. Process (230) is by iteself but Thread (232) has Process
            // object first
<span class="nc bnc" id="L136" title="All 2 branches missed.">            if (perfObject.ObjectNameTitleIndex == COUNTER_INDEX_MAP.get(objectName).intValue()) {</span>
                // We found a matching object.

                // Counter definitions start after the object header
<span class="nc" id="L140">                long perfCounterOffset = perfObjectOffset + perfObject.HeaderLength;</span>
                // Iterate counter definitions and fill maps with counter offsets and sizes
<span class="nc" id="L142">                Map&lt;Integer, Integer&gt; counterOffsetMap = new HashMap&lt;&gt;();</span>
<span class="nc" id="L143">                Map&lt;Integer, Integer&gt; counterSizeMap = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">                for (int counter = 0; counter &lt; perfObject.NumCounters; counter++) {</span>
<span class="nc" id="L145">                    PERF_COUNTER_DEFINITION perfCounter = new PERF_COUNTER_DEFINITION(</span>
<span class="nc" id="L146">                            pPerfData.share(perfCounterOffset));</span>
<span class="nc" id="L147">                    counterOffsetMap.put(perfCounter.CounterNameTitleIndex, perfCounter.CounterOffset);</span>
<span class="nc" id="L148">                    counterSizeMap.put(perfCounter.CounterNameTitleIndex, perfCounter.CounterSize);</span>
                    // Increment for next Counter
<span class="nc" id="L150">                    perfCounterOffset += perfCounter.ByteLength;</span>
                }

                // Instances start after all the object definitions. The DefinitionLength
                // includes both the header and all the definitions.
<span class="nc" id="L155">                long perfInstanceOffset = perfObjectOffset + perfObject.DefinitionLength;</span>

                // Iterate instances and fill map
<span class="nc" id="L158">                List&lt;Map&lt;T, Object&gt;&gt; counterMaps = new ArrayList&lt;&gt;(perfObject.NumInstances);</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">                for (int inst = 0; inst &lt; perfObject.NumInstances; inst++) {</span>
<span class="nc" id="L160">                    PERF_INSTANCE_DEFINITION perfInstance = new PERF_INSTANCE_DEFINITION(</span>
<span class="nc" id="L161">                            pPerfData.share(perfInstanceOffset));</span>
<span class="nc" id="L162">                    long perfCounterBlockOffset = perfInstanceOffset + perfInstance.ByteLength;</span>
                    // Populate the enumMap
<span class="nc" id="L164">                    Map&lt;T, Object&gt; counterMap = new EnumMap&lt;&gt;(counterEnum);</span>
<span class="nc" id="L165">                    T[] counterKeys = counterEnum.getEnumConstants();</span>
                    // First enum index is the name, ignore the counter text which is used for other
                    // purposes
<span class="nc" id="L168">                    counterMap.put(counterKeys[0],</span>
<span class="nc" id="L169">                            pPerfData.getWideString(perfInstanceOffset + perfInstance.NameOffset));</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">                    for (int i = 1; i &lt; counterKeys.length; i++) {</span>
<span class="nc" id="L171">                        T key = counterKeys[i];</span>
<span class="nc" id="L172">                        int keyIndex = COUNTER_INDEX_MAP.get(key.getCounter());</span>
                        // All entries in size map have corresponding entry in offset map
<span class="nc" id="L174">                        int size = counterSizeMap.getOrDefault(keyIndex, 0);</span>
                        // Currently, only DWORDs (4 bytes) and ULONGLONGs (8 bytes) are used to provide
                        // counter values.
<span class="nc bnc" id="L177" title="All 2 branches missed.">                        if (size == 4) {</span>
<span class="nc" id="L178">                            counterMap.put(key,</span>
<span class="nc" id="L179">                                    pPerfData.getInt(perfCounterBlockOffset + counterOffsetMap.get(keyIndex)));</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">                        } else if (size == 8) {</span>
<span class="nc" id="L181">                            counterMap.put(key,</span>
<span class="nc" id="L182">                                    pPerfData.getLong(perfCounterBlockOffset + counterOffsetMap.get(keyIndex)));</span>
                        } else {
                            // If counter defined in enum isn't in registry, fail
<span class="nc" id="L185">                            return null;</span>
                        }
                    }
<span class="nc" id="L188">                    counterMaps.add(counterMap);</span>

                    // counters at perfCounterBlockOffset + appropriate offset per enum
                    // use pPerfData.getInt or getLong as determined by counter size
                    // Currently, only DWORDs (4 bytes) and ULONGLONGs (8 bytes) are used to provide
                    // counter values.

                    // Increment to next instance
<span class="nc" id="L196">                    perfInstanceOffset = perfCounterBlockOffset</span>
<span class="nc" id="L197">                            + new PERF_COUNTER_BLOCK(pPerfData.share(perfCounterBlockOffset)).ByteLength;</span>
                }
                // We've found the necessary object and are done, no need to look at any other
                // objects (shouldn't be any). Return results
<span class="nc" id="L201">                return new Triplet&lt;&gt;(counterMaps, perfTime100nSec, now);</span>
            }
            // Increment for next object
<span class="nc" id="L204">            perfObjectOffset += perfObject.TotalByteLength;</span>
        }
        // Failed, return null
<span class="nc" id="L207">        return null;</span>
    }

    /**
     * Looks up the counter index values for the given counter object and the enum
     * of counter names.
     *
     * @param &lt;T&gt;
     *            An enum containing the counters, whose class is passed as
     *            {@code counterEnum}
     * @param objectName
     *            The counter object to look up the index for
     * @param counterEnum
     *            The {@link Enum} containing counters to look up the indices for.
     *            The first Enum value will be ignored.
     * @return A {@link Pair} containing the index of the counter object as the
     *         first element, and an {@link EnumMap} mapping counter enum values to
     *         their index as the second element, if the lookup is successful; null
     *         otherwise.
     */
    private static &lt;T extends Enum&lt;T&gt; &amp; PdhCounterWildcardProperty&gt; Pair&lt;Integer, EnumMap&lt;T, Integer&gt;&gt; getCounterIndices(
            String objectName, Class&lt;T&gt; counterEnum) {
<span class="nc bnc" id="L229" title="All 2 branches missed.">        if (!COUNTER_INDEX_MAP.containsKey(objectName)) {</span>
<span class="nc" id="L230">            LOG.debug(&quot;Couldn't find counter index of {}.&quot;, objectName);</span>
<span class="nc" id="L231">            return null;</span>
        }
<span class="nc" id="L233">        int counterIndex = COUNTER_INDEX_MAP.get(objectName);</span>
<span class="nc" id="L234">        T[] enumConstants = counterEnum.getEnumConstants();</span>
<span class="nc" id="L235">        EnumMap&lt;T, Integer&gt; indexMap = new EnumMap&lt;&gt;(counterEnum);</span>
        // Start iterating at 1 because first Enum value defines the name/instance and
        // is not a counter name
<span class="nc bnc" id="L238" title="All 2 branches missed.">        for (int i = 1; i &lt; enumConstants.length; i++) {</span>
<span class="nc" id="L239">            T key = enumConstants[i];</span>
<span class="nc" id="L240">            String counterName = key.getCounter();</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">            if (!COUNTER_INDEX_MAP.containsKey(counterName)) {</span>
<span class="nc" id="L242">                LOG.debug(&quot;Couldn't find counter index of {}.&quot;, counterName);</span>
<span class="nc" id="L243">                return null;</span>
            }
<span class="nc" id="L245">            indexMap.put(key, COUNTER_INDEX_MAP.get(counterName));</span>
        }
        // We have all the pieces! Return them.
<span class="nc" id="L248">        return new Pair&lt;&gt;(counterIndex, indexMap);</span>
    }

    /**
     * Read the performance data for a counter object from the registry.
     *
     * @param objectName
     *            The counter object for which to fetch data. It is the user's
     *            responsibility to ensure this key exists in
     *            {@link #COUNTER_INDEX_MAP}.
     * @return A buffer containing the data if successful, null otherwise.
     */
    private static Memory readPerfDataBuffer(String objectName) {
        // Need this index as a string
<span class="nc" id="L262">        String objectIndexStr = Integer.toString(COUNTER_INDEX_MAP.get(objectName));</span>

        // Now load the data from the regsitry.
<span class="nc" id="L265">        int bufferSize = 4096;</span>
<span class="nc" id="L266">        IntByReference lpcbData = new IntByReference(bufferSize);</span>
<span class="nc" id="L267">        Memory pPerfData = new Memory(bufferSize);</span>
<span class="nc" id="L268">        int ret = Advapi32.INSTANCE.RegQueryValueEx(WinReg.HKEY_PERFORMANCE_DATA, objectIndexStr, 0, null, pPerfData,</span>
                lpcbData);
<span class="nc bnc" id="L270" title="All 4 branches missed.">        if (ret != WinError.ERROR_SUCCESS &amp;&amp; ret != WinError.ERROR_MORE_DATA) {</span>
<span class="nc" id="L271">            LOG.error(&quot;Error reading performance data from registry for {}.&quot;, objectName);</span>
<span class="nc" id="L272">            return null;</span>
        }
        // Grow buffer as needed to fit the data
<span class="nc bnc" id="L275" title="All 2 branches missed.">        while (ret == WinError.ERROR_MORE_DATA) {</span>
<span class="nc" id="L276">            bufferSize += 4096;</span>
<span class="nc" id="L277">            lpcbData.setValue(bufferSize);</span>
<span class="nc" id="L278">            pPerfData = new Memory(bufferSize);</span>
<span class="nc" id="L279">            ret = Advapi32.INSTANCE.RegQueryValueEx(WinReg.HKEY_PERFORMANCE_DATA, objectIndexStr, 0, null, pPerfData,</span>
                    lpcbData);
        }
<span class="nc" id="L282">        return pPerfData;</span>
    }

    /*
     * Registry entries subordinate to HKEY_PERFORMANCE_TEXT key reference the text
     * strings that describe counters in US English. Not supported in Windows 2000.
     *
     * With the &quot;Counter&quot; value, the resulting array contains alternating index/name
     * pairs &quot;1&quot;, &quot;1847&quot;, &quot;2&quot;, &quot;System&quot;, &quot;4&quot;, &quot;Memory&quot;, ...
     *
     * These pairs are translated to a map for later lookup.
     *
     * @return An unmodifiable map containing counter name strings as keys and
     * indices as integer values if the key is read successfully; an empty map
     * otherwise.
     */
    private static Map&lt;String, Integer&gt; mapCounterIndicesFromRegistry() {
<span class="nc" id="L299">        HashMap&lt;String, Integer&gt; indexMap = new HashMap&lt;&gt;();</span>
        try {
<span class="nc" id="L301">            String[] counterText = Advapi32Util.registryGetStringArray(WinReg.HKEY_LOCAL_MACHINE, HKEY_PERFORMANCE_TEXT,</span>
                    COUNTER);
<span class="nc bnc" id="L303" title="All 2 branches missed.">            for (int i = 1; i &lt; counterText.length; i += 2) {</span>
<span class="nc" id="L304">                indexMap.putIfAbsent(counterText[i], Integer.parseInt(counterText[i - 1]));</span>
            }
<span class="nc" id="L306">        } catch (Win32Exception we) {</span>
<span class="nc" id="L307">            LOG.error(</span>
                    &quot;Unable to locate English counter names in registry Perflib 009. Counters may need to be rebuilt: &quot;,
                    we);
<span class="nc" id="L310">        } catch (NumberFormatException nfe) {</span>
            // Unexpected to ever get this, but handling it anyway
<span class="nc" id="L312">            LOG.error(&quot;Unable to parse English counter names in registry Perflib 009.&quot;);</span>
<span class="nc" id="L313">        }</span>
<span class="nc" id="L314">        return Collections.unmodifiableMap(indexMap);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>